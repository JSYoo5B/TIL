# 바꾸기

이제 각 통화 간 환율에 따라 환전이 가능하게 하자.

## 2 CHF == 1 USD로 환전하는 기능을 구현하자.

먼저 간단하게 환율을 고지하고, 환전 한 결과를 받는 테스트 코드를 작성하자.

```go
func TestReduceMoneyDifferentCurrency(t *testing.T) {
	bank := money.NewBank()
	bank.AddRate("CHF", "USD", 2)
	result := bank.Reduce(money.NewFranc(2), "USD")
	assert.True(t, money.NewDollar(1).Equals(result))
}
```

`Money` 안에서 `Reduce()`가 호출 될 때, 현재 통화 코드와 목적 통화 코드를 비교하여 일단은 통과를 시킬 수 있다.
하지만 이건 좋은 해결법도 아니며, 각 통화 별로 다른 통화에 대해 알아야 한다. `Money()`에서 `Reduce()` 할 때 환율을 참고할 수 있게 변경하자.

```go
type Expression interface {
	Reduce(bank *Bank, to string) Money
}
```

이제 `Bank`는 환율에 대한 정보를 등록할 수 있어야 하고, 기준 통화와 대상 통화에 대해 환율을 제공할 수 있어야 한다.
일단 실제 환율을 등록, 조회하는 부분은 하드코딩을 대체해서 테스트를 통과시켜보자.

```go
func (b *Bank) AddRate(from, to string, rate int) {
	// TODO: do something to register rate
}
func (b *Bank) Rate(from, to string) int {
	if from == "CHF" && to == "USD" {
		return 2
	} else {
		return 1
	}
}

func (m *money) Reduce(bank *Bank, to string) Money {
    rate := bank.Rate(m.currency, to)
    return newMoney(m.amount/rate, to)
}
```