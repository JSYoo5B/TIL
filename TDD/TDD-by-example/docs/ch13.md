# 진짜로 만들기

이제 가짜로 만들어서 통과시켰던 `Expression`을 실제로 구현해보자.

## 정방향으로 구현하기 (TDD의 역방향으로 구현하기)

기존 `Expression`의 구현을 하는 부분이 생각보다 복잡해서, 정방향으로 구현해보자. (구현 코드를 먼저 짜자)

결과적으로 아래와 비슷한 테스트 코드를 통과할 수 있어야 한다. (테스트 통과부터 작성하는 것이 아니다.)

```go
func TestPlusReturnsSum(t *testing.T) {
	five := money.NewDollar(5)
	result := five.Plus(five)
	sum := result.(*money.Sum)
	assert.True(t, five.Equals(sum.Augend))
	assert.True(t, five.Equals(sum.Addend))
}
```

일단 더하기를 구현하기 위한 `Sum` 구조체를 추가하고, `Plus()`가 `Sum`구조체와 호환되도록 변경하자.

```go
type Sum struct {
	Augend Money
	Addend Money
}

func NewSum(augend, addend Money) *Sum {
	return &Sum{
		Augend: augend,
		Addend: addend,
	}
}

func (m *money) Plus(addend Money) Expression {
    return NewSum(m, addend)
}
```

## Bank의 Reduce를 개선하자

이전의 `TestSimpleAddition`을 통과하기 위해 `Bank`의 `Reduce()`에 하드코딩해놓은 것이 있다.
이제 하드코딩된 코드가 문제임을 보이기 위해 새로운 테스트를 추가해보자.

```go
func TestReduceSum(t *testing.T) {
	sum := money.NewSum(money.NewDollar(3), money.NewDollar(4))
	bank := money.NewBank()
	reduced := bank.Reduce(sum, "USD")
	assert.True(t, money.NewDollar(7).Equals(reduced))
}
```

일부러 10이 나오지 않게 3+4로 테스트를 작성했고, 결국 실패한다.
이제 `Bank`의 `Reduce()` 코드를 개선해보자.

```go
func (b *Bank) Reduce(source Expression, currency string) Expression {
	sum := source.(*Sum)
	amount := sum.Augend.getAmount() + sum.Addend.getAmount()
	return newMoney(amount, currency)
}
```

하지만 이 코드는 2 단계에 걸쳐 `Amount`를 가져오는 문제가 있으며, private하게 처리하지도 못하고 있다. (딱히 `Augend`, `Addend`를 public하게 제공할 필요도 없으며, 실제 합산을 하는 행위는 `Sum`의 책임이라 볼 수 있다.)

`Sum`의 합산 작업을 메서드로 분리하여 책임을 나누고, `Bank`는 인자를 처리할 수 있게 변경하자.

```go
func (s *Sum) Reduce(to string) Money {
	amount := s.Augend.getAmount() + s.Addend.getAmount()
	return newMoney(amount, to)
}
func (b *Bank) Reduce(source Expression, currency string) Expression {
    sum := source.(*Sum)
    return sum.Reduce(currency)
}
```
