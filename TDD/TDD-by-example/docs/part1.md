# Part1을 진행하며

1. red-green-refactor 사이클을 강제로 책을 따라하며 진행해봤다.
2. 처음엔 너무 바보같은 반복 행위라 생각해서 TDD에 부정적이었으나, 생각보다 할 만 했다.
3. 생각보다 언어적 특성으로 인해 각 단계의 코드를 어떤 식으로 구현해야 할지 의문이 좀 있었다.

## 새로 느낀 점

1. `테스트 코드를 먼저 짠다`는 것은, `코드 수준의 요구사항을 먼저 정의한다`로 해석할 수 있다.
2. 반대로 말하면, `만들어 놓고 보니 못 쓰는 코드네` 하는 경우는 없다. (잘못된 설계로 기존 구현을 쓰지 못하고 버리는 경우가 없음)
3. 테스트만 통과시키기 위해 하드코딩하는 `Green` 사이클은 머리 싸매느라 멍때리는 시간을 강제로 줄여버린다. (강제로 통과시켜버리고, 문제를 풀게 강요한다.)
4. 이론상 목적이 정해진 코드의 구현은 빠르게 할 수 있지만, 안정성이 떨어져 보인다. (실 사용 시 생길 수 있는 코드 내 위험성을 간과하게 된다.)

## 궁금한 점

Q. red-green-refactor 사이클을 이 수준으로 바보같이 반복해야 하는가?  
A. hello world 같은 것이다. 그냥 최소한의 단계 변경을 보여주는 예시일 뿐이다.  
   뭔가 안 될때 printf를 하나하나 찍으면서 변경 내역을 파악하는 것과 같은 단계다.

Q. 각 테스트에서 경우의 수를 많이 다뤄야 하지 않을까?  
   다양한 입력, 논리적 분기를 다 추가해야 하지 않나?  
   그리고 검사도 너무 대충 하고, 한 테스트에서 여러 목적이 섞여 있는데 이게 맞나?  
A. 앞의 과정을 살펴보면, 기존 객체의 설계를 뒤엎는 리팩토링이 일어난다.  
   이 과정에서, 기존 테스트가 많이 실패하게 된다.  
   이 때, 테스트 코드도 같이 수정/리팩토링이 되어야 하는데, 수정할 부분이 많이 늘어나게 된다.

Q. 이번 예제에서는 처음부터 끝까지 직접 구현이라 드러나지 않는데,  
   실제 TDD를 적용하기 힘든 이유 중 하나는 외부 API를 사용하는 상황의 E2E 테스트다.  
   이렇게 내가 호출한 API, 함수가 어떤 결과를 내놓을지 잘 모르는 경우 어떻게 해야할까?  
A. 결국 내가 호출하는 함수, API에 대해 이해를 하고 있어야 작성할 수 있는 부분이다.  
   관련해서 책의 남은 부분에서 언급할 수도 있고, 안 할 수도 있다.  
   하지만 만약 라이브러리 형태로 제공을 받는다면? 함수의 내부 구현을 볼 수 없다면?  
   문서화도 안되어있다면 이건 그냥 경험 말고는 답이 없는듯.

## 아쉬운 점

테스트 코드가 가독성이 구리다. Given-When-Then 패턴에 맞게 작성했으면 좋겠는데, 테스트를 읽는 입장에서 짧아서 다행이지, 너무 길면 읽기 싫을 듯.

책에서 진행한 테스트 식으로 `이런 행동을 하면, 이런 결과가 나와야 한다` 하는 방식이 BDD 아닌가?

commit을 찍는 단계에 대해서도 언급을 해 줬으면 좋겠는데, 일단 임의로 진행했다.  
기본적으로 commit은 빌드가 가능하고, 심지어 테스트 코드도 모두 통과할 수 있어야 한다고 생각한다.  
commit 단위가 적절히 완성되어 있어야 bisect 등의 버그 찾기가 수월할텐데, 이런 언급이 없어서 아쉽다.
