# 프라이버시

기존 Amount 값을 private하게 변경하고 싶다.

## 테스트에서 private를 직접 접근하지 못하게 변경

golang은 멤버변수 혹은 메서드가 대문자로 시작하면 public, 소문자로 시작하면 private다.

하지만 현재 테스트 코드가 같은 패키지일 경우 접근이 제한된다. 먼저 지금의 테스트 코드가 public/private를 확인할 수 있게 패키지를 변경하자.

```go
package money_test

func TestMultiplication(t *testing.T) {
	five := money.NewDollar(5)

	product := five.Times(2)
	assert.Equal(t, 10, product.Amount)

	product = five.Times(3)
	assert.Equal(t, 15, product.Amount)
}
```

## 사용하는 테스트 검사 도구의 비교 기능 확인하기

이전 3장의 equality 관련 구현이 Java와 golang의 언어적 특성때문에 완벽하게 동일하진 않은 상태다.

하지만 지금 테스트의 일치 검사에 사용하는 testify의 assert는 자동으로 deep compare를 하고 있다. (단순한 포인터 주소값을 비교하지 않고, 각 포인터를 dereference하여 비교한다.)

이에 따라 아래와 같은 비교도 가능하다.

```go
func TestEquality(t *testing.T) {
    assert.False(t, money.NewDollar(5) == money.NewDollar(5))
    assert.Equal(t, money.NewDollar(5), money.NewDollar(5))
    assert.NotEqual(t, money.NewDollar(5), money.NewDollar(6))
}
```

첫 비교에서 address는 일치하지 않음을 검사했다. 같은 값이지만 둘의 포인터 주소를 비교했으므로 false다. 두 번째 비교와 세 번째 비교는 모두 기존 테스트에서 하던 비교와 동일하다. (deep compare를 하고 있다.)

## 테스트 코드도 리팩토링 하기

내부 코드를 리팩토링 하다보면 어느 부분에서 실패하는지 직관적으로 드러나지 않는다. golang의 subtest 개념으로 분리하자.

```go
func TestEquality(t *testing.T) {
	t.Run("pointer compare and deep compare", func(t *testing.T) {
		assert.False(t, money.NewDollar(5) == money.NewDollar(5))
		assert.True(t, *money.NewDollar(5) == *money.NewDollar(5))
		assert.False(t, *money.NewDollar(5) == *money.NewDollar(6))
	})

	t.Run("compare by methods", func(t *testing.T) {
		assert.True(t, money.NewDollar(5).Equals(money.NewDollar(5)))
		assert.False(t, money.NewDollar(5).Equals(money.NewDollar(6)))
	})

	t.Run("testify supports deep compare", func(t *testing.T) {
		assert.Equal(t, money.NewDollar(5), money.NewDollar(5))
		assert.NotEqual(t, money.NewDollar(5), money.NewDollar(6))
	})
}
```