# [Mock aren't Stub](https://martinfowler.com/articles/mocksArentStubs.html)

## `Mock`과 `Stub`에 대한 개념

* 테스트 할 대상을 `SUT`(System-Under-Test), `SUT`가 간접적으로 사용하는 객체를 `Collaborator`로 표현
* `SUT`만 순수하게 테스트 할 수가 없음. (특정 메서드의 인자로 들어가거나, 생성자 등 의존성이 주입됨)
* `SUT`테스트에 `Collaborator`가 필요한데, 모든 테스트에 맞춰 준비하기가 어렵다는 문제가 있음  
    예를 들어 DB에 저장된 값을 Read-Update 하거나 (반복 실험 등에 준비하기 어려움),  
    고객에게 알림 메일을 전송해야 하는 경우 (비즈니스 적으로 문제가 생길 수 있음)
* 그래서, `Collaborator`에 대한 `Test Double`(테스트 대역)이 필요함
  * Dummy: `SUT`의 메서드 인자를 채우기 위해 사용되지만, 실제 `SUT`의 동작에 영향을 주지 않는 값
  * Fake: 더 간단하게 구현된 대역 (ex. 실제 DB 대신 In-memory DB 등으로 대체)
  * Stub: `SUT`의 "미리 정해진 행동"을 제공함 (Fake 와 비슷하지만, 내부 로직이 테스트 전용으로 작성됨)
  * Spy: `SUT`의 "미리 정해진 답변" 처리 여부를 검증 (어떤 메서드가 어떤 인자로 호출되었는지 등)
  * Mock: `SUT`의 "미리 정해진 답변"을 제공함 (어떤 메서드가 어떤 입력으로 호출되면, 어떤 출력을 해야 하는지)
* `Mock`은 행동을 검증함 (ex. DB를 업데이트 하는 요청이라면, 저장은 안 했지만, 요청이 성공한 것으로 반환만 함)
  * `SUT`를 위한 `Collaborator`의 행동만 제공하며, 검증 대상이 `SUT`인 경우에 적합함
* `Stub`은 상태를 검증함 (ex. DB를 업데이트 하는 요청이라면, 실제 DB는 아니지만 저장된 상태를 제공함)
  * `SUT`가 `Collaborator`에 변화를 일으켰다면, 상태가 바뀐 `Collaborator`를 검증하는 경우에 적합함

## 고전파와 모의파의 테스트, `Mock`과 `Stub` 중 어느 것을 쓸 것인가?

* 고전파들은 가능하면 실제 객체를 사용하고, 불편한 경우에만 테스트 대역을 사용함
* 모의파들은 언제나 `Mock`을 사용한다. 행동에 집중하며, 심지어 `BDD`(Behavior Driven Development)를 파생시킴
* `BDD`는 `TDD`를 디자인 기법으로 사용하여 `TDD` 학습을 원활하게 하고자 했음  
    객체가 어떤 일을 해야하는 지 생각하게 함으로서, `Collaborator`가 어떻게 구현되어야 할 지를 생각하게 함

|             |    고전파   | 모의파 |
|:-----------:|:-----------:|:------:|
| 간단한 관계 |  실제 객체  |  Mock  |
| 애매한 관계 | 테스트 대역 |  Mock  |


* 고전파의 경우 상황에 따라 행동 검증, 상태 검증을 상황에 맞게 사용하지만, 모의파의 경우 모두 행동 검증만 사용함
* 사실 행동 검증이냐, 모의 검증이냐보단, 고전파냐 모의파냐 여부가 더 중요함
* 간단한 관계라고 해서 실제 객체를 사용하는 것이 부적합할 수도 있음 (캐시의 경우는 간단한 관계지만, 검증이 어려움)

## 그래서 고전파인가, 모의파인가?

* `TDD`를 통해 테스트 작성을 반복하면서 시스템 설계가 진화한다는 것이 신념
* 모의파는 "필요 기반 개발"이란 스타일을 옹호함
  * 일단 `SUT`를 테스트 할 수 있게 `Collaborator`를 `Mock`으로 대체함
  * 이후 `Collaborator`를 `SUT`로 취급하여, 이 과정을 반복함
  * `Collaborator`의 `Mock` 행동이 `SUT`가 되었을 때 검증 대상이 됨
  * 일종의 하향식 (Top-Down) 접근이라 볼 수 있음
* 고전파는 굳이 필요하다면 `Collaborator`를 `Stub`등으로 임시 구현함
  * 전반적으로 상향식 (Bottom-Up) 접근이라 볼 수 있음
  * 중간접근식 (Middle-Out) 접근을 하기도 함

## 각각의 문제점과 주장

* 고전파는 `Fixture`를 많이 생성하게 됨  
    대신 한 번 `Fixture`를 만들어놓으면 재사용 가능함  
    또한 `Collaborator`의 버그가 `SUT`의 테스트 실패로도 이어질 수 있음 (격리가 힘들 수 있음)  
    대신, 단위 테스트가 일종의 간단한 통합 테스트가 될 수도 있음
* 모의파는 위 고전파의 상황을 문제로 인식함  
    어차피 `Mock`으로 대체되어있어, 특정 `Collaborator`의 버그가 관련 테스트만 실패시킴  
    대신 모든 `Collaborator`가 `Mock`으로 구현되어야 함 (재사용이 불편함)  
    또한 테스트와 구현 사이 커플링이 생길 수 있음 (`Collaborator`의 변경이 `SUT`의 테스트를 수정하게 함)

## 전체적인 결론과 개인적 생각

저자는 어느 쪽을 결정해야 할 지는 어려운 문제지만 본인은 고전파이며, 모의파에 대해 설득력 있는 이점을 갖지 못한다고 생각함

개인적인 경험으로는 양 쪽 모두의 단점을 겪어봤다 생각함. (Full TDD 개발은 아니었지만, 테스트 코드의 접근법 기준)

### 고전파의 문제

* ORM 으로 작성된 Repository pattern 의 테스트를 할 때
  * 반복 테스트가 힘들어서 DB 서버를 메모리에 저장하는 sqlite 로 선정
  * 실제 환경은 다른 DB 서버를 사용함
  * DB 구현체가 변경되면서 sqlite 에서 생기는 문제의 코드가 추가되어야 함
  * 정작 실제 DB 환경에서 생기는 문제는 확인할 수 없었음 (DB 구현체가 달라서)
  * 결국 일종의 `Fake`로, 각 테스트의 DB 서버를 testcontainers 기반의 일회용 DB 서버로 교체함
* Upper layer 로 갈 때마다 `Collaborator` 의존성이 많아지고, 하나의 변화가 너무 많은 변화를 일으킴
  * 견고하게 테스트를 매번 작성했다면 문제가 작아보였을 수도 있지만, 마감에 쫓겨 일부 놓침
  * 의존성 하나의 수정이 많은 테스트를 실패시키는 데, 이를 파악하기 힘듬
* 아래 `Mock`의 문제를 해결하려고 `Fake`, `Stub`들을 작성하기로 함
  * 테스트 하나를 하기 위해 대역 구현을 많이 해야함
  * 조건에 맞춰 이것 저것 작성하다 보니, 점점 실제 구현이랑 비슷해짐
  * 심지어 정렬, 조건 검색은 DB 서버가 해줬는데, 이걸 구현해야 함

### 모의파의 문제

* 기존 테스트가 읽기 싫어짐
  * `Collaborator`의 동작이 `Mock`으로 구현되는데, `Mock` 하는 내용이 너무 많음
  * 작성한 사람은 논리적인 순서에 맞춰 `Mock`을 준비시키지만, 읽는 입장에서는 왜 하는지 모름
  * `Given-When-Then`에서 `Given`의 코드가 너무 길어지고, 준비 과정의 맥락별로 나누다 보면 어디가 `When-Then` 인지 헷갈림
  * 심지어 어디까지가 `Given`인지, `Then`의 코드가 길어지는 경우에도 `Mock` 준비가 생기는 경우도 있음 (사실 거기까지 `Given`일 수도 있음)
  * 정작 작성자도 시간이 지나면서 테스트의 어딜 수정해야 하는지도 헷갈림
  * Write-Once, Never-Read 처럼 느껴짐
* `Mock`이 재활용 되지 않는다는 점이 테스트를 통과한 버그를 만들어 냄
  * List 결과가 없는 경우, 출력 값이 null 이 맞는지, empty list 가 맞는지 헷갈림
  * 구현은 null 인데, `Mock`은 empty list 를 반환함
  * 테스트만 작성했을 때는 통과했지만, 실제 실행 시 버그가 발생함

### 개별적인 생각들

* 행동 검증이 일종의 함수형 패러다임을 생각나게 하는 부분이 있었음
  * 순수함수는 같은 입력이 들어오면 언제나 같은 값을 출력해야 함
  * 또한 side-effect 가 없어야 함
  * `Mock`은 실제로 뭔가 하지 않지만, 구현을 제외한 일종의 순수함수처럼 동작함
  * 하지만 안타깝게도, `Mock`등의 대역이 필요한 코드들은 순수함수로 작성될 수 없음
* 두 접근법을 조금 섞는 것이 가장 합리적이라 생각함
  * 개발 초기에는 모의파 방식으로 하향식으로 접근하여 빠르게 코드의 구조를 설계함
  * 전체적인 설계가 나온 상태에서, 상향식으로 구현하면서 `Mock`으로 작성된 부분을 구현, 실제 객체로 교체
  * 실제 객체를 사용하기 어려운 경우는 결국 `Fake` 혹은 `Stub`으로 교체해야 함
  * 반복하다 보면, 적절히 실제 객체와 테스트 대역을 섞은 반반 형태의 객체가 생성될 것이라 생각함
