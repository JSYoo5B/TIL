# 컴파일러 개요

## 컴파일러는 무엇을 하는가?

> 고급 언어로 작성한 프로그램을 기계어로 번역한다.  
> 대신 기계어, 어셈블리어로 직접 짜도 이론상 가능하지만, 사실상 불가능  
> (가독성, 이해력 제외하고) Portability(OS, arch)를 제공하지 못함

## 언어 번역기는 컴파일러 뿐인가?

* 컴파일러: 고급 언어 -> 기계어  
  기계어가 바로 실행파일로 만들어지기도 하고, 링커가 필요하기도 함. 실행은 로더의 몫
* 인터프리터: 고급 언어 -> 실행  
  기계어 형상의 실행 파일이 없고, 바로 뭔가 실행함  
* 트랜스파일러: 고급 언어 -> 다른 고급 언어  
  TypeScript의 타입 기반 문법 검사를 하되, 브라우저가 지원하는 JavaScript로 변경
* 크로스 컴파일러: 컴파일러인데, 컴파일러가 실행되는 환경과 기계어가 다름  
  실행 환경의 성능이 떨어져서, 실행 환경에서 개발 및 컴파일을 하기엔 성능이 못버티는 경우 사용 (ex. 임베디드)  
  LLVM같이 아키텍쳐 의존적인 부분을 분리해버리면 그냥 컴파일러 중 하나  
  의미 분석 및 중간 코드 생성 과정에서 아키텍쳐 의존적인 부분이 영향을 줄 수도 있음
* 어셈블러: 어셈블리어 -> 기계어  
  두 언어는 1:1 매칭같아보이지만, 어셈블리어가 표현력이 높음 (여전히 심볼을 사용함)  
  기계어는 실제로 변형되어 어떤 주소/값 만을 처리함
* JIT (Just-In-Time) 컴파일러: 인터프리터에서 부분적으로 컴파일러 활용  
  인터프리팅 하다보니 자주 실행되고, 최적화 가능한 부분이 발견되면, 그 부분만 컴파일

## 그럼 정확히 컴파일러는 뭘 하고, 다른 도구는 무슨 역할을 하는가?

* IDE == 에디터 + 컴파일러(+전처리기) + 링커 + 빌드 관리 + 디버거 + 프로파일러
* 에디터 자체에서 문법 검사 및 힌트, 자동완성 등을 제공하는데, 이건 사실상 라이브 컴파일러 같은 개념
* 전처리기는 컴파일러라고 하긴 애매함  
  기존 표현을 치환하기만 하며, 문법 구조가 매우 단순함  
  [위생적 매크로](https://en.wikipedia.org/wiki/Hygienic_macro)처럼 문법의 일부로서 컴파일러가 처리하는 경우도 있음
* 링커와 빌드 관리는 여러 파일에 걸쳐 코드를 나눠 작성할 때  
  각 코드의 컴파일 결과물을 연결하여 하나의 실행파일을 만들 때 사용  
  빌드 관리는 어떤 파일이 이미 컴파일되어있고, 변경분이 없는 경우 기존 결과물을 그대로 쓰게 하는 등 전체 빌드 과정 최적화
* 디버거는 코드를 실행하면서 의심되는 부분에 중지점을 걸고, 단계적으로 실행시킴  
  변수의 값을 확인하기도 하고, 현재 변수를 기준으로 어떤 연산의 값이 뭐가 나오는지 등을 확인함  
  해당 중지점의 시작에 해당하는 기계어를 `INT 3`(x86) `TRAP` or `BKPT`(ARM)으로 교체해서 코드 실행을 멈추게 함  
  이후 실제 명령어가 실행되어야 할 때, 원래 기계어로 교체하여 의도대로 실행되게 함
* 프로파일러는 각 함수의 실행 횟수, 실행 시간 등을 측정하여 보고함  
  해당 자료를 바탕으로 어디서 코드 실행이 오래 걸리는지 확인하여 코드 작성의 최적화 힌트를 제공함  
  심지어 [PGO](https://en.wikipedia.org/wiki/Profile-guided_optimization)처럼 프로파일러의 결과를 바탕으로 컴파일러 최적화를 추가 적용하기도 함

## 컴파일러의 구성은 어떻게 되는가?

* 코드 분석 과정 (FE)
  * 어휘 분석: 토큰 단위로 분석  
    `a*3`이 띄어쓰기 없이 입력되어도, 각각 `a`, `*`, `3` 단위로 나눌 수 있어야 함  
    `a$3`에서 `$`기호가 통용되지 않는 문법 토큰이라면 에러가 발생함
  * 구문 분석: Parse tree로 분석하여 AST 구성  
    주어진 토큰을 지정된 문법의 순서에 맞춰 구조화  
    `a-3`은 `-`인 빼기 연산이고, `a`의 값에서 `3`을 뺀다는 개념으로 표현  
    사칙연산 우선순위를 고려하여 `a+b*c`에서 `a`에 `b` 곱하기 `c`를 더한다는 식으로 표현  
    `a/`, `/b`, `a b` 같이 문법 구성에서 예상 토큰 유형이 누락되면 에러가 발생함
  * 의미 분석: AST를 해석하는 과정에서 유효한지 검사, 코드의 의미를 표현  
    변수/함수/상수 등의 선언 및 사용 확인을 위해 심볼 테이블을 구성  
    (앞에서 할 수도 있지만, 보통 의미 분석 과정에서 무슨 심볼인지 이해하면서 구성하는 편)  
    `a=1`은 `a`를 `1`이란 값으로 초기화한다는 뜻으로 해석함  
    `1+0.1`에서 타입 검사를 한다면, 서로 호환되지 않는 타입끼리의 덧셈이므로 경고/에러가 발생함  
    `1=b`는 상수 `1`에 변수 `b`의 값으로 초기화하라는 의미이므로 에러가 발생함  
    (이건 문법 구조에 따라 구문 분석에서 에러가 발생할 수도 있음)
* 코드 생성 과정 (BE)
  * 중간 코드 생성: machine independent  
    LLVM이 여러 아키텍쳐를 지원하기 위해 IR(Intermediate Representation)으로 표현  
  * 코드 최적화: 크기/성능 개선  
    실행 시간(Major), 전체 코드 크기(Minor)를 개선하고자 함  
    다만, 최적화 자체가 코드의 의미를 해치면 안됨
    * Local optimization: 간단한 수준의 짧은 거리 코드 최적화
      * Constant folding: 상수 값으로 사용될 계산을 꼭 런타임에 계산하지 않아도 되는 경우  
        (코드에서 3행 4열의 개수는 `3*4`로 의미를 두고 표현하지만, 최적화 단계에서는 그냥 `12`로 미리 계산해버림)
      * Eliminate redundant load/store instruction: 메모리에서 레지스터로 읽은 상태를 또 읽을 필요 없음 (쓰기도 동일)  
        하지만 가끔 임베디드같은 경우는 이런 짓을 해야해서, `volatile` 키워드로 최적화 금지를 요청
      * Algebraic simplication: 좀 더 빠른 & 대수적으로 짧은 연산으로 대체  
        `b = a + a + a` -> `b = 3 * a` 처럼 의미가 동일한 다른 방식으로 대체 (아래의 경우 반대로 적용되기도 함)
      * [Strength reduction](https://en.wikipedia.org/wiki/Strength_reduction): 시간이 많이 걸리는 코드를 짧게 걸리는 코드로 변경  
        아키텍쳐 상, 논리적인 개념 상 같은, 동일하면서 더 저렴한 연산으로 대체 (곱셈을 shift나 덧셈으로 대체)
    * Global optimization: 흐름 분석을 통한 최적화
      * 불필요한 반복문 요소 제거
      * 논리적으로 도달할 수 없는, 죽은 코드 제거
  * 목적 코드 생성: 실제 기계어 코드로 생성  
    한 파일만으로도 실행 파일이 생성되기도 하고, 여러 파일에 코드가 나눠진 경우 링커 등으로 다시 연결해줘야 함

## 컴파일 과정에서 최적화에 의해 다른 점은 무엇이 있는가?

* Visual Studio의 경우 기본 제공되는 DEBUG로 하면 최적화를 덜 함  
  이렇게 해야 변수/상수의 값 변경 과정을 브레이크 걸기 쉬움  
  물론 DEBUG/RELEASE는 컴파일러 옵션들을 간편하게 묶은 프로필일뿐, 서로 반대로 동작하게도 가능
* gcc나 clang(LLVM)은 최적화 레벨로 설정함
  * -O0: 최적화 안함 혹은 최소 단위 최적화  
  * -O1: 기초적인 최적화  
  * -O2: 성능과 코드 크기의 균형을 맞춤  
  * -O3: 최대 성능을 목표로 함. 코드 크기가 커짐. 캐시 문제를 일으킬수도 있음  
  * -Os: 코드 크기를 최소화 하는데 중점을 둠

## 컴파일러는 어떻게 만드는가?

모든걸 다 직접 짜기도 하지만, 보통 컴파일러를 만들어주는 컴파일러가 존재함

* LEX (어휘 분석 생성기)
* YACC (파서 생성기)
* ANTLR (어휘 분석 + 파서 모두 생성)

컴파일러 이론, 프로그래밍 언어론을 배우는 입장에서는 위 도구가 어떤 원리로 돌아가는지 이해가 필요하긴 함  
하지만 실제 언어 개발 입장에서는 문법을 단순하게 정의해서 바로 사용함  
대부분 자동화되기 때문에, 컴파일러를 구현하는 입장에서 전반부의 의미 분석을 제외하곤 하찮아짐

## 문법과 오토마타

### 문법의 복잡도에 따라 구분

* Type 0: 무제한 문법 (Unrestricted Grammar)
* Type 1: 문맥 의존 문법 (Context-Sensitive Grammar)
* Type 2: 문맥 자유 문법 (Context-Free Grammar)
* Type 3: 정규 문법 (Regular Grammar)

보통 숫자가 높은 Type 문법은 더 낮은 문법에 속하긴 함.  
근데 보통 편의성을 위해 여집합만 말한다

### 오토마타

* 튜링 기계 (Turing Machine)
* 선형제한 오토마타 (Linear-Bounded Automata)
* 푸시다운 오토마타 (Pushdown Automata)
* 유한 오토마타 (Finite Automata)

### 문법과 오토마타의 관계

문법은 오토마타와 1:1 매핑된다.  
문법을 오토마타로 기술할 수 있다.

* 무제한 문법 - 튜링 기계
* 문맥 의존 문법 - 선형제한 오토마타
* 문맥 자유 문법 - 푸시다운 오토마타  
  Parser의 이론적 기반이 됨
* 정규 문법 - 유한 오토마타  
  Lexer의 이론적 기반이 됨

## 프로그래밍 언어 이론

좋은 프로그래밍 언어의 요건

* 언어의 개념이 명확 (문법 구조, 의미)
* 프로그래머의 생각을 자연스럽게 표현
* 호환성(이식성), 신뢰성, 모듈화, 효율성
* 언어의 확장성이 우수
* 좋은 프로그래밍 환경
