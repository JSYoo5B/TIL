# Pumping Lemma

형식 언어 이론에서 특정 종류 언어의 속성을 나타내는 보조 정리

L이 어떤 형식 언어에 속한다면 그 언어에 해당하는 보조정리가 성립하지만, 그 역은 성립하지 않음. (필요조건)

어떤 특정 형식 언어에 속하지 않음을, 필요조건을 충족하지 않음을 보여주는 방법

> 특정 형식 언어라면 그 보조정리를 만족한다.  
> == 이 보조 정리를 만족하지 못한다면, 특정 형식 언어가 아니다 (대우)

## 정규 언어의 펌핑 레마

전제조건: **유한한** 규칙 혹은 오토마타로 **무한한** 단어들을 포함한 언어를 만들 수 있다.

* 단어들이 무한해야 하는 이유:  
    사용자가 어떤 입력을 해도 확장적으로 받을 수 있어야 한다.
* 규칙 혹은 오토마타가 유한해야 하는 이유:  
    무한한 요구사항을 무한하게 구현하려면 주소 공간이 무한해져야 한다.  
    (이론, 공리적으로는 가능하지만 현실은 불가능)

### 어떤 가정으로 시작하는가?

유한한 규칙으로 무한한 언어를 만든다고 했다.  
그렇다면 필연적으로 어떤 단어는 유한한 임의의 규칙보다 길 수도 있다.  
즉, 유한 오토마타의 상태가 3개이지만, 길이가 4 이상인 언어가 존재할 수 있다.

유한 오토마타는 단어의 현재 글자에 따라 상태가 변경되는 구조이다.  
다른 의미로 상태는 곧 글자의 입력이라 취급할 수 있다.  
그리고 오토마타 최적화, 언어의 각종 규칙에 의해 단어의 부분을 묶어서 substring을 하나의 글자처럼 취급할 수도 있다.  

아까 이야기한 상태가 p개이지만 길이가 p+1 이상인 단어라면, 어떤 한 상태는 2번 이상 방문했을 것이다. (비둘기 집 원리)  
즉, 어딘가 반복되는 부분이 생긴다.
위 논리를 다시 생각해보면, p+1 이상인 단어의 글자를 p개 인식하는 중간 상태라면, 이미 한 상태는 2번 이상 방문한, 반복된 지점이 발생했을 것이다.

그렇다면, 길이가 계속 늘어나는 언어를 아래와 같은 형식으로 표기할 수 있다.

$$
x y^i z
$$

여기서 y는 반복이 진행되는 substring을 의미하며, x와 z는 각각 반복 substring의 앞과 뒤를 뜻한다.  
실제 언어에서 반복으로 늘어나는 규칙이 2개 이상이더라도, 그 중 하나를 y로 취급하고, 나머지를 prefix, postfix substring으로 취급하자.  
당장 관심이 없는 반복 부분은 특정 횟수로 grounding한다고 생각하자.  
(필요하다면 상황에 따라 y가 될 부분을 변경하면 된다.)

### 추가 규칙

위의 규칙대로 언어를 재표기했다면, 아래와 같은 규칙을 만족한다.

$$
| x y | \leq p
$$

아까 p 이상의 길이를 읽기 위해선 p개 상태중 한 곳이 2번 이상 방문되었을 것이라고 했다.  
즉, 시작에서부터 반복 지점까지의 길이는 p와 같거나 더 작을수 있다.

## 펌핑 시작

$$
x y^i z
$$

아까 얘기했던, 상태보다 길이가 더 긴 언어가 존재하려면, 위의 식 처럼, 반복되는 부분이 있어야 한다.  
여기에서 이제 i값을 늘리거나 줄여서 다시 만들어낸 언어가 기존의 언어 문법을 지키는가 여부로 정규 언어 여부를 판정한다.

## 실제 펌핑 진행 과정

특정 언어가 정규언어라고 가정한다.
그렇다면 이 정규 언어는 펌핑이 가능한 길이 p가 존재한다.  
다만, 길이를 변수로 유지해야 한다. 임의로 값을 투입하면 안된다.  

우리의 목적은 모든 경우의 일반화가 아닌, 하나의 실패만 확인하면 된다.  
전략적으로 필요조건을 실패시킬 적절한 다음 단어를 선택하면 된다.  

이제 p를 활용하여, 확실하게 p보다 긴 문자열 하나를 전략적으로 선택한다.  
처음 길이 p 각각 상태를 표현했다면, 새로 선택한 단어는 p보다 길기 때문에, 그 임의의 단어 p의 길이 이내에 반복지점을 가져야 한다. (펌핑 식으로 표현)

이 과정에서, 초기 p에 비해 적절한 임의의 단어를 선택했다면, 전략적으로 반복되는 y의 경우의 수를 줄일 수 있게 된다.

이후, y의 반복 횟수를 늘리거나 줄였을 때, 원래 주어진 언어의 문법을 따르지 않는다면, 해당 문법이 정규 문법이 아님을 보일 수 있게 된다.