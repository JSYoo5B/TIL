# 문맥 자유 문법

정규문법보다 좀 더 표현력이 좋은 언어

프로그래밍 언어의 구문을 문맥 자유 문법으로 표현한다

문장의 구조 분석에 용이함

chomsky 문법의 type 2에 해당함

## 문맥 자유 문법의 정의

Non-terminal symbol으로부터 생성 규칙이 non-terminal, terminal symbol이 모두 가능함

정규 문법의 경우 왼쪽에서 오른쪽으로 / 오른쪽에서 왼쪽으로만 늘어나게 했지만  
(즉, 생성 규칙에서 terminal symbol이 왼쪽/오른쪽에만 있어야 함)

문맥 자유 문법은 이런 제한이 없음 (대신 입력 non-terminal symbol은 하나여야 함)

정규문법이 이렇게 오른쪽으로만 늘어난다면

> A -> tB | t

문맥 자유 문법은 이렇게 양쪽으로 늘어날 수도 있음.  
(이전에 펌핑 레마에서 본 대표적인 정규문법이 아닌 언어)

> A -> aAb | ab

## 유도와 유도 과정 (derivation, 확장)

start symbol로 부터 문장을 생성하는 과정

생성 규칙을 통해 terminal symbol들로만 구성된 하나의 문장을 만드는 과정

### 좌단 유도와 우단 유도

non-terminal symbol이 2개 이상 있는 경우, 왼쪽부터 확장할 것인가, 오른쪽부터 확장할 것인가

## 파싱 (parsing, 축소)

주어진 terminal symbol들을 가지고, 어떤 symbol의 표현인지 다시 구조화 하는 과정

유도와 반대로 주어진 문장을 다시 non-terminal symbol화 하여 어떤 문법을 사용했는지 알아낸다.

즉, 코드를 구조화 하는 과정임.

### AST (Abstract Syntax Tree)

위 파싱 과정에서 만들어낸 트리 중 실제 코드 생성에 관심이 없는 부분은 생략하고 구조화한다.

예를 들어, C언어에서는 문장의 종료로 `;`를 사용한다.

세미콜론은 해당 표현이 이전 라인에서 이어서 진행중인지, 멈춘것인지 구분하기 위해 문법에서는 분명 필요한 존재이고, parse tree에는 존재해야 한다.

하지만 코드 생성 과정에서 `;` 그 자체는 의미를 갖지 않는다.

비슷한 예시로 `while (1)` 에서 `()`는 큰 의미를 갖지 않는다. (while의 조건부를 표현하는 것이지, 괄호 자체가 의미를 가지지 않는다.)

또한 사칙연산 수식 예시에서 괄호 또한 먼저 처리되어야 한다는 우선순위만을 의미할 뿐, 우선순위가 적용된 트리에서는 괄호 자체가 의미를 갖지 않는다.

## 문법의 모호성

어떤 입력 스트링을 parsing했을 때, 2개의 다른 모양으로 유도 가능한 문법

그래서, 모호하지 않게 단계를 두어 생성 규칙을 기술해야 한다.

### 모호성을 유발하는 생성규칙 #1 (수식 표현)

좌항에 표현된 non-terminal symbol이 생성규칙 오른쪽에 2회 이상 사용되는 경우 (간접 재귀로 해당 심볼이 다시 사용되는 것은 문제가 없음)

그래서 보통 새로운 non-terminal symbol을 도입하여 모호성을 제거한다.

> E -> E + E | E * E | (E) | a

위에서는 자꾸 E를 재활용하기 때문에, 어떤 규칙을 먼저 적용하느냐에 따라 우선순위가 바뀐다.

> E -> E + T | T  
> T -> T * F | F  
> F -> (E) | a

이렇게, 덧셈 수식 E > 곱셈수식 T > 실제 항 F (괄호로 새로운 수식의 결과가 항이 됨) 순으로 작성하면 제일 안에 있는 기호가 가장 우선순위를 가지게 구성할 수 있다.

### 모호성을 유발하는 생성규칙 #2 (dangling else)

if-then-else 형태의 문법을 기술할 때, 특정 생성규칙이 다른 생성규칙을 포함하는 경우

> S -> if C then S else S  
> S -> if C then S  
> S -> x | y | z  
> C -> a | b

위와 같은 생성 규칙이 있다고 했을 때, `if a then x if b then y else z` 라는 문장이 들어왔다면

z를 하기 위한 else의 조건은 a가 거짓인가? b가 거짓인가? (마지막 else의 짝은 첫번째 if인가 두번째 if인가?)

보통 이런 경우, 해석 방식을 고정함. C의 경우 가장 가까운 if문에 붙이게 되어있음. Python은 indent depth를 활용하여 주인을 찾게 함.

### 모호성을 유발하는 생성규칙 #3 (본질적으로 모호한 문법)

문법 자체가 이미 모호하다면? 이건 답이 없음

## 문법의 동등성

다시 과거로 돌아가서, 문법이 생성하는 언어가 동일하다면, 두 문법은 동일하다.

즉, 특정 문법 기술 방법은 불필요하게 비효율적일수도 있고, 내가 쓴 문법이 모호할 수도 있다.

이 경우 동등한 문법으로 변환하여 효율적이게 문법을 기술하거나, 모호성을 제거할 수 있다.

주로 생성규칙을 적용하면서 대입하거나, 확장하면서 새로운 형태의 문법으로 변경한다.

## 불필요한 생성 규칙 제거

* Non-terminating symbol  
  non-terminal symbol의 생성규칙이 terminal symbol을 생성하지 않는 경우  
  (non-terminal이 재귀/반복 되는데 생성규칙을 적용해도 terminal symbol이 늘어나지 않음)
* Inaccessible symbol  
  시작 기호로부터 도달이 불가능한 symbol (terminal, non-terminal 관계 없음)
  마치 사용하지 않는 변수와 비슷함

## 표현법

Chomsky Normal Form, Greibach Normal Form, Backus-Naur Form, Extended BNF 등이 있음

실질적으로 EBNF만 사용한다고 생각하면 된다.