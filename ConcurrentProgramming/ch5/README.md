# 비동기 프로그래밍

작성 순서에 따라 실행 흐름이 확정적인 것은 `동기 프로그래밍`이라 한다.

`비동기 프로그래밍` 구현 방법으로 콜백, 시그널 등이 있으나, 책에서는 Future, async/await 방식을 설명하고, 결과적으로 tokio를 사용하는 방법을 설명한다.

## 동시 서버

약간 일본식 번역 문제인거같긴 한데, 반복 서버는 주어진 동작이 끝까지 끝난 다음에 완료하는 것을 말하며, 동시 서버는 주어진 동작 중에 동시성을 지원할 수 있을 때 활용하는 것을 말한다.

반복 서버의 코드를 보면, 커넥션 요청, 데이터 도착 등 처리를 모두 하나의 간단한 흐름으로 묶어서 처리하고 있다.

동시 서버는, 이 과정을 각각 쪼개서 단계별로 완료될 때 까지 기다릴 수 있는 것을 말한다.  
방법으로는 Unix 계열 전체는 select/poll, 리눅스는 epoll 지원, BSD는 kqueue를 지원한다.

책에서는 epoll을 쓰다보니, 맥 환경은 BSD계열이라 epoll을 사용할 수 없다.  
대략 코드를 보면, epoll을 통해 소켓의 file descriptor의 이벤트를 감시하고, 리슨 이벤트 처리, 클라이언트 데이터 처리를 분리하여 비동기 처리를 지원한다.

## 코루틴과 스케쥴링

### 코루틴

여기서 말하는 코루틴은 중단-재개가 가능한 함수를 총칭한다.

* 대칭 코루틴: 코루틴들이 caller-callee 주종관계 없이 서로 호출
* 비대칭 코루틴: 코루틴이 임의 중단만 제공하며, 다음 대상을 정할 수 없음

Rust의 경우 coroutine을 직접 제공하지는 않지만, poll 함수와 내부 상태를 통해 단계적인 기능을 호출때마다 다르게 실행할 수 있다.

### 스케줄링

비대칭 코루틴을 유저가 직접 실행하는 것이 아니라, 스케줄링을 통해 자동으로 실행되게 할 수 있다.

대충 흐름을 보면, 운영체제의 스케쥴링과 같이 time preemption으로 임의로 실행흐름이 조절당하게 여러 스레드를 동작시키는 것이 아니라, 부분적으로 동작하는 비대칭 코루틴(분할되어 동작하는 여러 함수)을 알아서 실행시키게 하는 것이다.

코루틴으로 구성함으로서, 크리티컬 섹션이 공유되지 않게 코드를 구성하여 실행할 수 있다. (내가 스케쥴링 되는 시점을 조정하므로, 기대하지 않은 동기화 문제를 피할 수 있다.)

## async/await

### Future와 async/await

Future는 미래의 언젠가의 시점에서 값이 결정되는 것을 나타내는 데이터타입을 뜻한다. 언어에 따라 Promise 혹은 Eventual로 불린다.

(특정 값을 선언되는 시점에서 결정하지 않고, 실제 사용되는 시점 이전에 언젠가 결정될 수 있는 개념)

### IO 다중화와 async/await

이전의 동기서버 작성 과정을 async/await로 future 개념 도입으로 프로그래밍하는 것을 볼 수 있다.

## 비동기 라이브러리

이전의 IO 다중화, async/await의 코드 단순화, 각 IO 처리에 대한 쓰레드 자원 준비를 쓰레드풀 기반으로 실행하는 것까지 tokio가 자동으로 해준다.

이렇게 async 할 때는 블로킹 코드를 실행하지 않아야 한다. worker thread가 블로킹으로 낭비되는 셈이기 때문이다. 알아서 async/await에 의해 스케줄링 기반으로 동작하게 해야 한다. (async context 내에서 blocking 함수를 실행하면 안된다는 경고도 출력된다.)

기본 sleep이 아닌, tokio 등이 제공하는 sleep을 써야한다. (지정된 시간 이전까지 스케줄링 되지 않게 방지하는 방식이다.)