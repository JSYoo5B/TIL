# 프로그래밍 기본

간략하게 각 언어, 간단한 아키텍쳐 별 특징에 대해 학습한다.

## 어셈블리 언어

어셈블리 언어는 기계어 수준의 코드를 좀 더 가독성있게 작성하는 것이다.

보통 명령어를 `Mnemonic`이라 하며, 대상을 `Operand`라 한다.

### Aarch64 어셈블리

ARM 64-bit 아키텍쳐는 아래와 같은 특징을 가진다.

* 범용 레지스터를 여러 개 가지고 있다.
* 수식 연산에 Operand를 3개까지 받을 수도 있다. (레지스터가 많은 것과 연계)
* 메모리 접근 명령과, 레지스터 간 값 변경 명령어가 분리되어 있다.
* 기계어 길이가 고정적이다.

### x86-64 어셈블리

* 범용 레지스터 개수가 적다. (x86-64부터 범용 레지스터가 더 늘어나긴 했다.)
* 대부분 연산은 Operand를 2개 이하로 받는다.
* 메모리 접근 명령과, 레지스터 간 값 변경 명령이 합쳐져있다.
* 기계어 길이가 가변적이다.

## C언어

C언어는 원래 "개발자가 생각이 있어서 이렇게 작성했겠지"라고 생각하는, 강력하면서도 위험한 언어다.

### pthread

POSIX 표준 인터페이스를 갖춘 스레드 라이브러리를 뜻한다.  
`pthread_join`으로 돌아가는 스레드를 대기하여 자원을 반환할 수 있으며,  
`detach` 속성으로 스레드가 알아서 자원을 반환하게 할 수 있다.

### volatile

컴파일러가 임의로 최적화 하지 못하게 하는 키워드다.

### 스택 메모리와 힙 메모리

스택에 보통 지역변수나 caller 반환 점수를 저장한다.  
함수의 인자 및 반환 값 전달은 레지스터를 사용하는 것이 일반적인 calling convention이다.
callee의 주소 영역은 반환 후 caller가 다른 함수를 호출하면 오염될 수 있다.  
이에 따라, 힙 영역에 동적으로 메모리를 할당받아서 제공해야 한다.

## Rust 언어

사소한, 기초적인 언어 내용이 많으니, 간단하게 특이한 특성만 다루고 넘어가자.

### 타입 시스템

#### 기본 타입

정수형은 비트 길이 위주로 타입을 선언한다.

그 외에, 여러 타입을 묶기 위해 `(type1, type2, ...)` 식의 튜플을 정의할 수 있고, 배열은 기존 언어들과 비슷하게 `[1, 2, 3, ...]` 식으로 정의할 수 있고, `[0; 30]`식으로 앞의 값이 뒤의 숫자만큼 반복되게 표현할 수 있다.

#### 사용자 정의 타입

`struct`로 여러 타입을 묶어서 새로운 타입을 정의할 수 있다.  
`enum`은 그냥 값만을 열거하는 것이 아니라, `union`처럼 여러 타입 중 하나가 될 수 있는 값으로 취급할 수 있다.  
`enum`의 타입 중 하나로 사용되는 것을 다른 타입으로 강제로 해석할 수는 없지만, 한 변수를 여러 타입 중 하나로 취급할 수 있다.

#### 제네릭스

구조체 등으로 직접 타입을 정의하지 않고, 타입을 변수처럼 변경할 수 있게 한다.

위의 `enum`을 활용하여, `Option<T>`, `Result<T, E>` 타입을 사용할 수 있으며, 함수형의 monad 구현에 사용할 수 있다.

#### 참조 타입

소유권 이야기할 때 추가로 이야기하도록 하겠다.

### 기본 문법

#### let문

변수를 정의하는 방법이다. `let`은 다시 선언하여 변수 값을 재정의할 수 있다.

`mut` 키워드 없이 선언할 경우, immutable이 된다. 일반적으로 변수 선언 뒤에 값을 변경할 수 없다.

#### 함수 정의

`fn`으로 정의하고, 함수명 - 인자 - 반환값 - 함수 내용 순으로 작성한다.

함수에서는 명시적으로 `return`을 할 수도 있고, 그냥 값만 마지막에 작성하면 그것이 반환값이 된다.

함수와 비슷하게 생긴 매크로가 있는데, 이 경우는 `func()` 대신 `macro!()` 식으로 `!`가 뒤에 붙는다.

#### if, match, for, loop

대부분 기존 프로그래밍 언어와 비슷하다. `match`는 `enum` 타입이 들어올 때, 각 열거 타입을 구분할 수 있다.

#### 참조 취득과 참조 제외

`&`으로 참조 변수로 취급할 수 있고, 해당 참조의 값을 접근할 때 (dereference) `*`으로 접근할 수 있다. (C의 포인터와 비슷하게 생각하면 된다. 하지만 엄밀하게 참조와 포인터는 다르다.)

#### 함수 포인터

함수 자체를 인자로 전달하여, 어떤 동작의 구현체를 동적으로 설정하게 할 수 있다.

#### 클로저

함수 포인터를 사용하는 방식의 일종인데, 특정 함수 포인터와 그 함수를 만드는 과정의 변수를 연결할 수 있다.

### 소유권

rust는 소유권 개념이 도입되어있다. 즉, 변수는 한 함수가 소유(인자 전달 혹은 반환) 혹은 대여(참조)할 수 있다.

### 라이프타임

변수가 선언되는 block 범위에 따라 라이프타임을 가지며, 함수 호출에 인자를 넘기게 되면 소유권이 없는 것과 함께 알아둬야 한다.

### 차용

함수 호출에 인자를 넘기면 소유권이 넘어가므로, 해당 값을 다시 사용하려면 무조건 함수는 그 값을 다시 반환해서 소유권을 돌려줘야 한다.

그것보다는 참조를 통해 소유권을 빌려줄 수 있다.

### 메서드 정의

구조체가 자기 자신을 참조하는 함수나, 해당 구조체 타입과 관련된 맥락을 가지는 함수들을 메서드라 한다.

메서드는 구조체가 실체할때만 사용 가능한 메서드와, 구조체가 없이도 호출할 수 있는 정적 메서드가 존재한다.

메서드의 정의는 `impl`로 해당 타입에 메서드를 정의할 수 있으며, 일반 메서드는 첫 인자로 `&mut self` 가 존재해아하며, 정적 메서드는 해당 인자를 제외한다.

### 트레이트

인터페이스와 비슷한 개념이다.

트레이트의 정의에서 요구하는 메서드들을 구현한다면, 해당 트레이트로 취급할 수 있다.

### ? 연산자와 unwrap

위에서 언급한 `Option`, `Result`가 어떤 타입인지 확인하기 위해 매번 `match`가 필요한데, 이를 `?` 혹은 `.unwrap()` 메서드를 통해 간소화 할 수 있다.