# 동시성과 병렬성

동시성과 병렬성이라는 유사해보이는 두 개념을 정확히 구별하고자 한다.  
간단하게 말하면 아래와 같다.

* 동시성: 특정 단위 시간 기준으로 봤을 때, 2개 이상의 프로세스가 계산하고 있다.
* 병렬성: 특정 순간을 봤을 때, 2개 이상의 프로세스가 계산하고 있다.

## 프로세스

여기에서는 OS 관점이 아니라, 계산을 중점으로 보고 있기 때문에 상태값 중 IO 상태가 빠져있다.  
기존 OS 관점과 매핑하여 설명해보자.

1.  실행 전 상태  
    프로세스가 처음 생성될 때의 상태다.  
    프로세스를 실행하기 위한 준비가 끝나면 사실상 대기 상태로 전이된 셈이지만, 특수한 대기 형태로 취급할 수 있다.
2.  실행 상태  
    계산을 실행하고 있는 상태다.  
    운영체제에서 말하는 User space CPU time에 해당한다.  
    실행 상태는 여러 사유로 대기 상태에 전이된다.
3.  대기 상태  
    계산을 하고 있지 않는 상태를 말한다.  
    실행 상태에서 IO를 실행할 경우, IO가 완료되기 전 까지는 CPU를 낭비하게 되어 대기 상태로 간다.  
    실제 IO로 인한 CPU 낭비는 아니지만, 동기화 등을 위해 대기하는 경우에 CPU를 반납하기도 한다. (가끔 안하는 전략도 있다.)  
    위의 경우들은 프로세스가 자발적으로 대기하는 것이라면, 멀티프로그래밍 관점에 의해 preempt로 강제 대기당할 수 있다.  
4.  종료 상태  
    해야할 일을 다 끝내고 종료하는 상태다.  
    OS 관점에서도 실제로 실행상태에서 종료상태로 넘어간다.  
    대기 상태에서 종료되는 경우는 없다. (자발적 종료던, 비자발적 종료던 모두 동일하다.)

## 동시성

동시성을 판별하는 기준에서는, 프로세스가 `실행 상태` 혹은 `대기 상태` 모두 `계산 중`으로 취급한다.  
특정 시간에서 여러 프로세스들이 `계산 중`이라면 `동시 실행 중` 이라고 할 수 있다.

예를 들어, 싱글 프로세서 환경임에도 `여러 프로세스가 돌아가면서 실행하고 있다면` 이건 `동시 실행 중`이라고 할 수 있다.

## 병렬성

병렬성을 판별하는 기준에서는, 프로세스가 `실행 상태`에 있는 것을 중점으로 본다.  
특정 시간에서 여러 프로세스들이 `실행 상태`라면 `병렬 실행 중`이라고 할 수 있다.

### 태스크 병렬성

앞에서 말한 여러 프로세스들이 `실행 상태`인 것을 말하며, 여기서 말하는 `프로세스`의 관점은 OS 프로세스 혹은 쓰레드를 뜻한다.

### 데이터 병렬성

여러 데이터가 동시에 처리되는 것을 말한다.

예를 들어 2개의 벡터(배열 등 같은 자료형의 여러 데이터를 모은 것)가 있다고 할 때  
순차적으로 실행된다면(ex. 하나씩 계산하는 반복문) 병렬적이지 않지만,  
CPU의 AVX 혹은 neon 등을 활용하여 동시 계산하거나, GPU의 행렬 계산은 병렬적이다.  
물론 여러 쓰레드를 동시에 실행해서 계산하는 것도 데이터 병렬성이다. (물론 효율이 잘 안나올 수 있다.)

#### 응답 속도와 처리량

* 응답 속도: 계산을 시작해서 마칠 때까지 시간
* 처리량: 단위 시간 당 실행 가능한 계산량

#### 암달의 법칙

병렬화를 통해 응답 속도를 얼마나 향상할 수 있는가에 대한 법칙이다.

$$
\frac{1}{(1-P)+\frac{P}{N}}
$$

해당 식의 의미는 병렬화 가능한 영역의 비율이 응답속도 향상에 얼마나 의미를 가지는지 뜻한다.  
실무적인 상황에서는 병렬화 과정 및 합산 과정에서 오버헤드가 소요되므로, 병렬화 자체가 성능을 개선하는데는 한계가 있다.

### 인스트럭션 레벨 병렬성

CPU의 명령어 레벨에서 병렬화를 수행하는 방법

파이프라인 처리 기법이란 개념은, CPU 내 명령어가 내부적으로 여러 단계를 거치는데, 이 내부 단계를 동시에 실행하는 것을 말한다.

간단하게 아래 5단계로 구성된다고 치자.

* IF (Instruction Fetch, 명령어 읽기)
* ID (Instruction Decode, 명령어 해석)
* EX (Execute, 실제 명령어 해석)
* MEM (Memory Access, 메모리 접근)
* WB (Write Back, 연산 결과 쓰기)

이 때, 명령어 하나가 위 5단계를 거쳐 마무리될 때 까지 기다릴 필요가 없다.  
ID 하는 동안 IF 기능은 쉬고 있으므로, 동시에 다음 명령어의 IF를 하는 방식이다.  
CPU 내 모든 요소가 쉬지 않고 클럭 낭비를 최소화 하는 방식이다.

가끔 파이프라인을 최적화 하지 못하는 경우에 대한 해저드가 발생한다.

* 구조 해저드  
    파이프라인 내 단계가 필요로 하는 자원이 중복되는 경우, 후행 명령어가 대기한다.
* [데이터 해저드](https://en.wikipedia.org/wiki/Data_dependency#Data_hazards)  
    MEM, WB의 결과가 다음 명령어에 영향을 끼치는 경우, 후행 명령어에게 준비될 때 까지 대기한다.
* 제어 해저드  
    조건 분기에 의해 어떤 명령어가 다음 명령어가 될지 모르기 때문에 대기한다.

파이프라인을 제외하고 인스트럭션 레벨 병렬성을 고려한 프로그래밍 예시 혹은 CPU 내부 최적화는 아래와 같다.

* 루프 전개  
    반복문은 결국 실행 흐름을 뒤바꾸는 분기를 사용하게 됨  
    반복문 내 코드가 짧을 경우, 분기가 파이프라인 효율을 방해함
  * [Loop unrolling](https://en.wikipedia.org/wiki/Loop_unrolling)
  * [Duff's Device](https://en.wikipedia.org/wiki/Duff%27s_device)
* 데이터 프리페치
  * 메모리에 미리 데이터를 읽어 두는 것이 필요할 때 데이터를 가져오는 것 보다 효율적
  * IO -> 메모리 -> 캐시 순으로 미리 읽어두는 것이 속도에 영향을 줌
* 비순차적 명령어 처리 (CPU 내 동작)
  * 명령어 간 의존성 관계가 없는 명령어를 순서에 관계없이 미리 실행
  * 혹은 메모리 로딩과 관계 없는 명령어를 순서에 관계없이 미리 실행
* 투기적 실행 (CPU 내 동작)
  * 분기문에 의해 실행되지 않을 수도 있는 코드를 미리 실행
  * 분기문의 방향성이 결정되면 투기적 실행 결과를 commit

## 동시 처리와 병렬 처리의 필요성

### 병렬 처리와 성능 향상

앞의 병렬성 종류 중 데이터 병렬성, 인스트럭션 레벨 병렬성은 컴파일러나 하드웨어가 암묵적으로 수행한다.  
(성능 최적화를 시도하는 것이며, 신뢰도와 연계되는 이슈고, 동작 방식이 이미 정해져있다.)

하지만 태스크 병렬성은 개발자가 어떤 동작 방식을 가질 지 알 수 없다.  
(상위 추상화 레벨에 해당하며, 의도를 가진 코드의 영역이므로, 알아서 성능 최적화나 신뢰도를 확보해야 한다.)

병렬 처리를 할 수 밖에 없는 원인은, 하드웨어 때문이다.  
책에서는 반도체 기술의 제한을 이야기한다. 현실적인 조건 외에 모든 것이 이상적이라 해도, 어차피 빛의 속도 제한으로 인해 최대 클럭은 제한되어 있다.

### 동시 처리의 필요성과 계산 경로 수 급증

동시 처리가 중요한 이유는 효율적인 계산 리소스 활용, 공평성, 편리성을 들 수 있다.

IO 시간동안 계산 리소스가 낭비되는 것을 방지하기 위해 멀티프로그래밍이 시작되었고,  
사용자가 여러 작업을 동시 실행하려고 하면서, 공평하게 여러 프로그램이 실행되어야 했고,  
실제 사용자의 요구사항이 많아짐에 따라 편리성을 위해서도 동시 처리가 필요해졌다.

반면, 동시성은 복잡성이라는 문제를 안고 있다.  
예를 들어 동시 프로세스가 여러 개 있게 되면, 그 프로세스 개수마다 실행 순서의 경우가 많아진다.  
이 때, 각 프로세스가 순서에 의존적이라면, 일부 순서가 틀어지는 경우 버그가 발생하게 된다.