# 동시성 프로그래밍 특유의 버그와 문제점

동시성 특유의 버그와 문제점을 알아본다.

먼저 잠금 그 자체가 일으키는 데드락, 라이브락, 굶주림 등 기본적인 문제를 알아본다.

이후 재귀락, 의사 각성과 같은 문제를 설명한다.

## 데드락

대표적으로 식사하는 철학자 문제로 알려진 문제다. 이론상 4가지 조건이 동시에 성립할 때 발생한다.

1. 상호 배제 -> lock 자체가 상호배제를 기본으로 한다.
2. 점유 대기 -> 둘 이상의 자원을 점유해야 한다.
3. 비선점 -> 상대의 자원을 강탈할 수 없어야 한다.
4. 순환 대기 -> 자원의 할당과 요청 관계가 여분 없이 순환을 이룬다.

책에서는 일종의 state machine으로 만들고, state 중 다른 state로 전환이 불가능한 경우에 진입하는 것을 데드락이라고 표현한다.

## 라이브락

데드락과 비슷하지만, 서로 양보하느라고 데드락과 비슷한 증상이 발생하는 경우를 말한다.

데드락의 점유 대기 상태를 해소하고자 기존 lock을 푸는 방법을 두지만, 결국 기본적인 논리가 데드락 발생 과정과 동일하므로, 점유 해소 -> 점유 -> 전체 점유 시도 -> 점유 해소 식으로 반복된다.

책에서 state machine 예시는 state가 다른 state로 전환이 불가능하진 않지만, 계속 특정 반복만 일어나는 경우를 뜻한다. (식사하는 철학자 문제는 계속 반복하게 되어있지만, 일단 식사 자체가 불가능하고 계속 포크만 들었다 내리는 경우를 뜻한다.)

## 은행원 알고리즘

자원 할당이 유효한지 미리 고려하여 자원을 할당하는 방식이다.

## 재귀 락

락을 획득한 상태에서 다시 락을 획득 시도하는 경우를 말한다.

락의 기본 로직에서는 어떤 프로세스가 락을 걸었는지, 이미 이 프로세스가 락을 가진 프로세스인지 확인하지 않기 때문에, 실수로 락을 연속으로 시도하면 `내가 락을 건 상태에서, 내 락이 풀리길 기다리는` 데드락이 걸리게 된다.

재귀 락을 수행해도 데드락 상태에 빠지지 않고, 처리를 계속 할 수 있는 락을 `재진입 가능 락`이라 한다.

참고로 재진입 가능 락에서 재귀 락을 걸었으면, 잠금이 여러 번 걸린 것 처럼 동작해야 한다. (잠금을 건 만큼 해제해야 실제 해제되어야 한다.)

pthread에서는 재진입 불가능한 락(데드락), 재진입 가능한 락, 재진입 오류를 발생시키는 락 옵션을 mutex 생성할 때 걸어줄 수 있다.

## 의사 각성

> 특정한 조건이 만족될 때까지 대기 중이어야 하는 프로세스가 해당 조건이 만족되지 않았음에도 불구하고 실행 상태로 변경되는 것

책에서 보여준 예시는 조건 변수 대기에 의해 무한루프에 멈춰야 하는데 시그널 수신으로 인해 조건 변수 대기가 풀리는 것을 보여준다.

## 시그널

시그널 자체는 프로세스에 이벤트를 알리는 간단한 도구다. 하지만 시그널 핸들러에서 동기화 도구를 잘못 사용하면 락이 걸린다.  
(커널 내에서도 데드락이 걸리는 대표적인 사유가 인터럽트 핸들링 과정에서 의도치않게 락이 순환 참조를 일으키는 경우다.)

책에서는 시그널 전용 핸들러 스레드를 만들어서 돌리는 방법을 소개한다.

## 메모리 배리어

CPU의 성능 향상을 위해 순서와 관계없이 명령어를 실행하기도 한다.

책의 예시는 메모리, 캐시 등 위치에 따라 접근 속도가 달라서 명령어 처리 순서가 바뀌는 경우를 말하고 있다.

어쨌은 비순차 실행은 성능 최적화를 위해 사용하지만, 이로 인해 동작성이 틀어져선 안된다. 그래서 특정 순간을 기점으로 비순차 실행을 방지하기 위한 기능이 필요하다.

ARM은 메모리 배리어, Intel은 메모리 펜스라고 부른다.

평소에는 딱히 메모리 배리어를 걸지 않아도 되지만, 동기화 도구를 사용하는 상황 등에서는 필수적이다.

물론 과도하게 잦은 메모리 배리어는 비순차실행을 방해하고, 실질적인 `nop`를 만들어내므로, 과도한 배리어 호출, 혹은 배리어 조건을 최소화하여 호출하는 것이 성능 향상에 중요하다.

위와 같이 메모리 읽기/쓰기 수행하는 순서를 메모리 오더링이라 말하며, 원래 코드 순서와 다른 순서로 실행되는 것을 리오더링이라 한다. 메모리 오더링이 다양하게 가능한 환경을 약한 메모리 모델이라 한다.

[메모리 오더링](https://en.wikipedia.org/wiki/Memory_ordering#Runtime_memory_ordering) 문서를 보면 다양한 패턴에 대해 각 아키텍쳐 별로 가능 여부를 설명하는데, x86은 매우 제한적인 반면, Alpha는 매우 유연한 것을 볼 수 있다.  
참고로 Alpha는 이미 단종된 아키텍쳐지만, 저렇게 다양한 메모리 오더링이 가능하기 때문에 모든 동시성 문제의 기준점이 된다.