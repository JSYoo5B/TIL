# 동시 처리 2

## 공평한 배타 제어

스핀락을 제공할 때, 여러 스레드가 동시에 스핀락을 얻으려 할 때, 컨텐션을 줄이는 방법을 고안한다.

### 약한 공평성을 보장하는 락

1. 락을 해제할 때, 다음 우선순위 스레드를 배려한다.
2. 만약 다음 우선순위 스레드가 없다면 공평하게 경쟁하게 한다.

### 티켓 락

락을 가져오는 순서대로 티켓을 발급하고, 티켓 차례가 오면 접근하게 한다.

컨텐션 자체를 발급 신청하는 순서대로 우선순위를 잡게 하여 컨텐션을 줄인다.

### MCS 락

티켓락의 문제는 락을 기다리는 모든 스레드가 같은 변수를 접근한다는 것이다.

각 스레드가 개별적인 CPU core에서 동작중이라면 캐싱에 영향을 줄 수 있기 때문에 불필요한 낭비가 생길 수 있다.

어차피 락을 기다리는 입장에서는 내 번호 근처에 와야 의미가 있는데다, 여러 스레드가 같은 변수를 접근하는 횟수를 줄이기 위해 MCS락을 도입한다.

각 티켓을 링크드 리스트처럼 기다리는 순서대로 배치하고, 내 락이 풀릴 때 다음 락을 찾아서 락을 풀어주는 방식으로 실행한다. 티켓을 새로 얻을 때마다 마지막 티켓을 가리키게 한다.

## 소프트웨어 트랜잭셔널 메모리

기존 다룬 동기화/잠금 방식은 크리티컬섹션 진입 자체를 허가된 경우에만 할 수 있게 하는데, 트랜잭셔널 메모리 방식은 투기적으로 코드를 실행하고, 경합이 감지되지 않았을 때 실제 커밋하는 방식이다. (LL/SC 방식과 비슷한 개념이지만 범위가 다르다.)

트랜잭셔널 메모리 구현에는 하드웨어적, 소프트웨어적 구현이 있으며, 그 중 소프트웨어적 구현은 Haskell, Closure가 유명하다. 소프트웨어적 구현방법인 TL2 알고리즘과 구현방법을 알아본다.

소프트웨어 트랜잭셔널 메모리의 중요 특징은 아래와 같다.

1. 트랜잭션 중인 코드가 2회 이상 실행될 가능성이 있다.  
    경합이 발생하면 바로 커밋하지 않고 재실행해야 하기 때문이다.
2. 트랜잭션 중에 부작용이 잇는 코드는 실행하지 않는다.  
    부작용(side effect)이 존재하면, 원치 않는 외부 연동이 발생하기 때문이다.
3. 데드락이 발생하지 않는다.  
    잠금, 배타적 동작이 일어나지 않기 때문이다.
4. 여러 트랜잭션 처리를 합성할 수 있다.  
    여러 합성 자료구조를 동시 사용하는 경우, 전체 락을 걸거나, 락프리 자료구조를 조합할 필요가 있는데, 이 문제에서 자유로워진다.

### TL2 알고리즘

타임스탬프 기반 트랜잭션의 원리와 비슷하다.

## 락프리 데이터 구조와 알고리즘

배타락(다수 스레드의 동시 접근 제어를 막음) 없이 사용 가능한 자료구조 및 조작 알고리즘을 다룬다.

아토믹하게 데이터를 업데이트 해야 하므로, compare and swap을 이용한다.

### 락프리 스택

간단하게 설명하자면, 링크드 리스트로 구성된 스택에서, Head의 업데이트를 할 때 CAS로 등록/삭제를 한다.

### ABA 문제

ABA 문제의 핵심은 업데이트 여부 검사의 핵심이 CAS를 통해 이뤄지기 때문이다.
CAS는 값의 일치여부를 기준으로 업데이트를 시키므로, 만약 메모리가 검사한 부분은 일치하고, 검사되지 않는 부분이 일치하지 않는 상황이 발생하게 된다면 ABA 문제가 발생하는 것이다.

책에서는 LL/SC를 통해 해결하는 방법을 제안하고 있다. 보이지 않은 변조 여부에 대해 확인할 수 있기 때문이다. (같은 값을 write해서 CAS의 ABA 문제와 동일하게 재현해도, LL/SC는 캐시라인 등에 대한 확인이 포함되기 때문이다.)

ARM64는 LL/SC를 제공하지만, x86-64는 해당 명령어를 제공하지 않기 때문에 메모리 태그 방식을 활용한다. (double check CAS 방식과 비슷하게, 메모리 주소 + 카운터/버전 등을 포함하여 CAS 하는 방식이다)

### 멀티스레드에서의 참조에 관한 문제

멀티스레드가 여럿이 동시에 락프리 자료구조를 사용할 때, 다른 스레드가 접근중인 데이터를 임의로 해제하면 댕글링 포인터 문제가 발생하게 된다.

기존 Rust는 소유권으로 잠금을 구현했었고, 임의로 메모리 해제가 발생하지 않았지만 락프리 구조에서는 다시 발생할 수 있다.

해결법으로 일종의 GC가 필요하다. 가장 유명한 해결법은 hazard pointer 방식이다. (누가 쓰고 있다면 그 여부를 리스트에 기록해두는 방식)

### 락프리 분류

보통 배타락을 사용하지 않는 경우를 락프리라고 하며, 굳이 엄밀하게 Lock에서 자유로운지 확인하기 위해, 추가 분류를 한다.

* 배타 락프리 (Obstruction-freedom): 배타 락을 사용하지 않음
* 락프리 (Lock-freedom): 라이브락이 발생하지 않음. (배타 락프리 포함)
* 웨이트 프리 (Wait-freedom): 굶주림이 발생하지 않음. (락프리 포함)
