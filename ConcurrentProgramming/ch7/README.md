# 동시 처리 2

## 공평한 배타 제어

스핀락을 제공할 때, 여러 스레드가 동시에 스핀락을 얻으려 할 때, 컨텐션을 줄이는 방법을 고안한다.

### 약한 공평성을 보장하는 락

1. 락을 해제할 때, 다음 우선순위 스레드를 배려한다.
2. 만약 다음 우선순위 스레드가 없다면 공평하게 경쟁하게 한다.

### 티켓 락

락을 가져오는 순서대로 티켓을 발급하고, 티켓 차례가 오면 접근하게 한다.

컨텐션 자체를 발급 신청하는 순서대로 우선순위를 잡게 하여 컨텐션을 줄인다.

### MCS 락

티켓락의 문제는 락을 기다리는 모든 스레드가 같은 변수를 접근한다는 것이다.

각 스레드가 개별적인 CPU core에서 동작중이라면 캐싱에 영향을 줄 수 있기 때문에 불필요한 낭비가 생길 수 있다.

어차피 락을 기다리는 입장에서는 내 번호 근처에 와야 의미가 있는데다, 여러 스레드가 같은 변수를 접근하는 횟수를 줄이기 위해 MCS락을 도입한다.

각 티켓을 링크드 리스트처럼 기다리는 순서대로 배치하고, 내 락이 풀릴 때 다음 락을 찾아서 락을 풀어주는 방식으로 실행한다. 티켓을 새로 얻을 때마다 마지막 티켓을 가리키게 한다.

## 소프트웨어 트랜잭셔널 메모리

기존 다룬 동기화/잠금 방식은 크리티컬섹션 진입 자체를 허가된 경우에만 할 수 있게 하는데, 트랜잭셔널 메모리 방식은 투기적으로 코드를 실행하고, 경합이 감지되지 않았을 때 실제 커밋하는 방식이다. (LL/SC 방식과 비슷한 개념이지만 범위가 다르다.)

트랜잭셔널 메모리 구현에는 하드웨어적, 소프트웨어적 구현이 있으며, 그 중 소프트웨어적 구현은 Haskell, Closure가 유명하다. 소프트웨어적 구현방법인 TL2 알고리즘과 구현방법을 알아본다.

소프트웨어 트랜잭셔널 메모리의 중요 특징은 아래와 같다.

1. 트랜잭션 중인 코드가 2회 이상 실행될 가능성이 있다.  
    경합이 발생하면 바로 커밋하지 않고 재실행해야 하기 때문이다.
2. 트랜잭션 중에 부작용이 잇는 코드는 실행하지 않는다.  
    부작용(side effect)이 존재하면, 원치 않는 외부 연동이 발생하기 때문이다.
3. 데드락이 발생하지 않는다.  
    잠금, 배타적 동작이 일어나지 않기 때문이다.
4. 여러 트랜잭션 처리를 합성할 수 있다.  
    여러 합성 자료구조를 동시 사용하는 경우, 전체 락을 걸거나, 락프리 자료구조를 조합할 필요가 있는데, 이 문제에서 자유로워진다.

### TL2 알고리즘

타임스탬프 기반 트랜잭션의 원리와 비슷하다.
