# git branch 관리

```sh
# Cancel rebase
$ git rebase --abort

# Restore branch to origin state
# git reset --hard origin/master
```

rebase -i 할 때는, 관련된 가장 최신 commit에서 edit 등을 걸어야 한다.  
내 기억으로는 git에서 commit tree 관리가 linked list 식으로 구현되는데 
그런 이유로 미래의 commit을 현재의 commit에서 관리할 수 없다.

# git blame
blame을 이용하면 현재 코드 각 라인 별로 어느 commit에서 수정되었는지 알 수 있다. 
하지만 해당 commit 작성자가 해당 기능의 작성자라고 할 수 없다.

예를 들어, author A가 alpha에 대한 기능을 추가하여 0123456 이란 commit으로 올렸다.  
그리고 author B가 alpha 기능에 관련된 코드를 리팩토링해서 7890abc로 commit해서 올렸다면 
마치 alpha 기능의 책임자가 author B로 파악될 수 있다. 리팩토링 과정에서 버그가 있다면 
이것은 author B가 실수한 것이지만, 원본 기능인 alpha 자체에 문제가 있었을 경우 
author B는 해당 부분에 책임이 없으므로, 관련 논의는 author A와 해야 한다.

만약 해당 코드 파일이 git mv와 같은 상태로 처리되었다면, blame시 파일 경로가 다르게 보인다.
파일 이전시, commit hash 옆에 파일 이름이 나타난다. 

blame시 이전 commit의 file 상태를 보려면 아래와 같이 한다.
```
$ git blame <COMMIT_ID> <FILE>
```
